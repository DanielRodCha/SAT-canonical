<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>ToolN</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_ToolN.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/ToolN.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">SAT-Pol-0.1.0.0</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">ToolN</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module aims to provide an efficient tool to solve the SAT
 problem. Both the algorithm and the implementation have been carried out by
 the researchers from the department of Computer Science and Artificial
 Intelligence at the University of Seville.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:toolN">toolN</a> :: <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:deltaRule">deltaRule</a> :: <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="PolAux.html#t:PolF2">PolF2</a></li><li class="src short"><a href="#v:deltaRule1Step">deltaRule1Step</a> :: <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> <a href="PolAux.html#t:PolF2">PolF2</a></li><li class="src short"><a href="#v:nextN">nextN</a> :: <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> (Vect F2 (Lex <a href="../base-4.9.1.0/Data-String.html#t:String">String</a>)) -&gt; <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> <a href="PolAux.html#t:PolF2">PolF2</a></li><li class="src short"><a href="#v:nextNRec">nextNRec</a> :: (<a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> t, <a href="../base-4.9.1.0/Data-Eq.html#t:Eq">Eq</a> t) =&gt; t -&gt; <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> (Vect F2 (Lex <a href="../base-4.9.1.0/Data-String.html#t:String">String</a>))</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:toolN" class="def">toolN</a> :: <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/ToolN.html#toolN" class="link">Source</a> <a href="#v:toolN" class="selflink">#</a></p><div class="doc"><p><strong>(tool (ps,vvs))</strong> is verified if the original set of formulas which
 polynomials from <em>ps</em> came was satisfiable. Otherwise, the function will
 return False if that set of formulas was unsatisfiable. Note that <em>vvs</em> is
 the set of variables which occurs in any polynomial from <em>ps</em>. For example,</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>tool (S.fromList[1],S.empty)
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>tool (S.fromList[x1,x1+1],S.fromList[x1])
</code></strong>False
</pre></div></div><div class="top"><p class="src"><a id="v:deltaRule" class="def">deltaRule</a> :: <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="PolAux.html#t:PolF2">PolF2</a> <a href="src/ToolN.html#deltaRule" class="link">Source</a> <a href="#v:deltaRule" class="selflink">#</a></p><div class="doc"><p>(deltaRule v p1 p2) is the polynomial obtained from apply the independence
 rule described in the paper [?] between polynomials <em>p1</em> <em>p2</em> respect the
 variable <em>v</em>. It's important to note that as <em>v</em> is the variable from wich we
 derive, it won't occurs in the output polynomial. For example,</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>deltaRule x1 1 1
</code></strong>1
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>deltaRule x1 1 0
</code></strong>0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>deltaRule x1 x1 x1
</code></strong>1
</pre></div></div><div class="top"><p class="src"><a id="v:deltaRule1Step" class="def">deltaRule1Step</a> :: <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> <a href="PolAux.html#t:PolF2">PolF2</a> <a href="src/ToolN.html#deltaRule1Step" class="link">Source</a> <a href="#v:deltaRule1Step" class="selflink">#</a></p><div class="doc"><p><strong>(deltaRule1Step v pps acum)</strong> is the union of the set <em>accum</em>, which
 ramains invariant, and the set of polynomials obtained after applying
 deltaRule respect <em>v</em> between every polynomial from set <em>pps</em>. For example,</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>deltaRule1Step x1 (S.fromList [x1]) (S.fromList [1])
</code></strong>fromList [1]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>deltaRule1Step x1 (S.fromList [x1,x1*x2,x1*x3]) (S.empty)
</code></strong>fromList [x2x3,x2,x3,1]
</pre></div></div><div class="top"><p class="src"><a id="v:nextN" class="def">nextN</a> :: <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> (Vect F2 (Lex <a href="../base-4.9.1.0/Data-String.html#t:String">String</a>)) -&gt; <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> <a href="PolAux.html#t:PolF2">PolF2</a> <a href="src/ToolN.html#nextN" class="link">Source</a> <a href="#v:nextN" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:nextNRec" class="def">nextNRec</a> :: (<a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> t, <a href="../base-4.9.1.0/Data-Eq.html#t:Eq">Eq</a> t) =&gt; t -&gt; <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> <a href="PolAux.html#t:PolF2">PolF2</a> -&gt; <a href="../containers-0.5.7.1/Data-Set.html#t:Set">Set</a> (Vect F2 (Lex <a href="../base-4.9.1.0/Data-String.html#t:String">String</a>)) <a href="src/ToolN.html#nextNRec" class="link">Source</a> <a href="#v:nextNRec" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>