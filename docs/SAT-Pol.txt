-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package SAT-Pol
@version 0.1.0.0


-- | This module contains several examples in order to verify the good
--   functioning of the other modules.
module PolExamples
x1 :: LexPoly F2 String
examples :: [LexPoly F2 String]
exampleSet :: Set (LexPoly F2 String)
exampleMonomial1 :: Lex v
exampleMonomial2 :: Lex [Char]
exampleMonomial3 :: Lex [Char]
ej2 :: Vect F2 (Lex String)
ej1 :: LexPoly F2 String
ej3 :: LexPoly F2 String

module PolAux

-- | The data type PolF2 is the field of polynomial with coefficients in
--   the finite field F2.
type PolF2 = Vect F2 (Lex String)

-- | (<b>expTo1 p</b>) is the representative with leastest degree of the
--   polynomial p in the quotient group
--   F2[x_1,...,x_N]/(x_1+x_1^2,...,x_N+x_N^2). The main idea is to replace
--   every ocurrence of x_i^M with x_i thus we obtain an identical
--   polynomial without exponents greater than 1.
--   
--   In the library HaskellForMaths exists a function that performs the
--   same (%%) so we can check the results. For example,
--   
--   <pre>
--   &gt;&gt;&gt; expTo1 (x1^3)
--   x1
--   
--   &gt;&gt;&gt; (x1^3) %% [x1^2+x1]
--   x1
--   
--   &gt;&gt;&gt; expTo1 (x1^3*x2^6+x3^2*x4+x1+1)
--   x1x2+x1+x3x4+1
--   
--   &gt;&gt;&gt; let pol = x1^3*x2^6+x3^2*x4+x1+1
--   
--   &gt;&gt;&gt; let list = [x1^2+x1,x2^2+x2,x3^2+x3,x4^2+x4]
--   
--   &gt;&gt;&gt; pol %% list
--   x1x2+x1+x3x4+1
--   </pre>
expTo1 :: PolF2 -> PolF2

-- | (<b>deriv p v</b>) is the derivative of the polynomial p with respect
--   to the variable v. It's important to note that deriv only works if it
--   applies to polynomials without exponents greater than 1. In practice,
--   deriv will only be used with the polynomials that have been previously
--   embeded in the quotient group described above. For example,
--   &gt;&gt;&gt; let v = x1 &gt;&gt;&gt; deriv v v 1 &gt;&gt;&gt; deriv
--   (1+x1+x2+x1*x2) v x2+1 &gt;&gt;&gt; deriv (x1*x2+x1+x3*x4+1) v x2+1
deriv :: PolF2 -> PolF2 -> PolF2
var :: (Num k, MonomialConstructor m) => v -> Vect k (m v)
vars :: (Num k, Ord k, MonomialConstructor m, Ord (m v)) => Vect k (m v) -> [Vect k (m v)]
zerov :: Vect k b
mindices :: MonomialConstructor m => forall v. m v -> [(v, Int)]
lm :: Vect b c -> c
lt :: Vect t1 t -> (t, t1)

module LogicAux
newtype Var
Var :: String -> Var
data Expr
Variable :: Var -> Expr
Negation :: Expr -> Expr
Conjunction :: Expr -> Expr -> Expr
Disjunction :: Expr -> Expr -> Expr
Conditional :: Expr -> Expr -> Expr
Biconditional :: Expr -> Expr -> Expr

-- | Represents expressions using only ASCII characters (the <a>show</a>
--   function pretty-prints expressions using logical symbols only present
--   in extended character sets).
showAscii :: Expr -> String
showBinaryConnective :: (Expr -> String) -> String -> Expr -> Expr -> String
showBC :: String -> Expr -> Expr -> String
showBCA :: String -> Expr -> Expr -> String
variables :: Expr -> [Var]
declaraVar :: (Num k, MonomialConstructor m) => Expr -> [Vect k (m Var)]
instance GHC.Classes.Eq LogicAux.Expr
instance GHC.Classes.Ord LogicAux.Var
instance GHC.Classes.Eq LogicAux.Var
instance GHC.Show.Show LogicAux.Var
instance GHC.Show.Show LogicAux.Expr

module LogicFunctions
form2Pol :: Expr -> Vect F2 (Lex String)
pol2Form :: MonomialConstructor m => Vect k (m String) -> Expr
ex :: [Expr] -> Set PolF2
kb :: [Expr]
kb' :: [Expr]
kb'' :: [Expr]
kb5 :: Expr
kb''' :: [Expr]


-- | This module contains several examples in order to verify the good
--   functioning of the other modules.
module Examples
clause2pol :: [String] -> (PolF2, Set (PolF2))
insertPol :: (Ord a, Ord a1) => (a1, Set a) -> (Set a1, Set a) -> (Set a1, Set a)
var' :: String -> (PolF2, PolF2)
fileSat0 :: [[Char]]
fileSat00 :: (Set PolF2, Set PolF2)
var'' :: String -> PolF2
clause2pol' :: [String] -> PolF2
variable2List :: (t, Set a) -> (t, [a])
fileSat0' :: Set PolF2
fileSat0'' :: (Set PolF2, Set PolF2)
fileSat0''' :: (Set PolF2, [PolF2])
fileSat1 :: [[Char]]
fileSat1' :: Set PolF2
fileSat1'' :: (Set PolF2, Set PolF2)
fileSat1''' :: (Set PolF2, [PolF2])

module Heuristics
heuristics :: (Ord (m v), Ord k, MonomialConstructor m, Num k, Foldable t, Foldable t1) => t1 (Vect k (m v)) -> t (Vect k (m v)) -> [Vect k (m v)]


-- | This module aims to provide an efficient tool to solve the SAT
--   problem. Both the algorithm and the implementation have been carried
--   out by the researchers from the department of Computer Science and
--   Artificial Intelligence at the University of Seville.
module Tool

-- | <b>(tool (ps,vvs))</b> is verified if the original set of formulas
--   which polynomials from <i>ps</i> came was satisfiable. Otherwise, the
--   function will return False if that set of formulas was unsatisfiable.
--   Note that <i>vvs</i> is the set of variables which occurs in any
--   polynomial from <i>ps</i>. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tool (S.fromList[1],[])
--   True
--   
--   &gt;&gt;&gt; tool (S.fromList[x1,x1+1],[x1])
--   False
--   </pre>
tool :: (Set PolF2, [PolF2]) -> Bool

-- | (deltaRule v p1 p2) is the polynomial obtained from apply the
--   independence rule described in the paper [?] between polynomials
--   <i>p1</i> <i>p2</i> respect the variable <i>v</i>. It's important to
--   note that as <i>v</i> is the variable from wich we derive, it won't
--   occurs in the output polynomial. For example,
--   
--   <pre>
--   &gt;&gt;&gt; deltaRule x1 1 1
--   1
--   
--   &gt;&gt;&gt; deltaRule x1 1 0
--   0
--   
--   &gt;&gt;&gt; deltaRule x1 x1 x1
--   1
--   </pre>
deltaRule :: PolF2 -> PolF2 -> PolF2 -> PolF2

-- | <b>(deltaRule1Step v pps acum)</b> is the union of the set
--   <i>accum</i>, which ramains invariant, and the set of polynomials
--   obtained after applying deltaRule respect <i>v</i> between every
--   polynomial from set <i>pps</i>. For example,
--   
--   <pre>
--   &gt;&gt;&gt; deltaRule1Step x1 (S.fromList [x1]) (S.fromList [1])
--   fromList [1]
--   
--   &gt;&gt;&gt; deltaRule1Step x1 (S.fromList [x1,x1*x2,x1*x3]) (S.empty)
--   fromList [x2x3,x2,x3,1]
--   </pre>
deltaRule1Step :: PolF2 -> Set PolF2 -> Set PolF2 -> Set PolF2

-- | <b>(next v ps)</b> is the set of polynomials obtained after applying
--   deltaRule respect <i>v</i> between every polynomial from <i>ps</i>,
--   except if a zero is obtained, in which case the process is stopped and
--   the calculation is not continued. For example, &gt;&gt;&gt; next x2
--   (S.fromList [x2,x1*x2,x1+1]) fromList [x1,x1+1,1] &gt;&gt;&gt; next x1
--   (S.fromList [x1,x1+1,1]) fromList [0]
next :: PolF2 -> Set PolF2 -> Set PolF2
toolTrace :: (Set PolF2, [PolF2]) -> [(Set PolF2, PolF2)]


-- | This module aims to provide an efficient tool to solve the SAT
--   problem. Both the algorithm and the implementation have been carried
--   out by the researchers from the department of Computer Science and
--   Artificial Intelligence at the University of Seville.
module ToolCount

-- | <b>(tool (ps,vvs))</b> is verified if the original set of formulas
--   which polynomials from <i>ps</i> came was satisfiable. Otherwise, the
--   function will return False if that set of formulas was unsatisfiable.
--   Note that <i>vvs</i> is the set of variables which occurs in any
--   polynomial from <i>ps</i>. For example,
toolCount :: Integer -> (Set (PolF2), Set (PolF2)) -> (Bool, Integer)
toolLC :: Integer -> (Set (PolF2), [PolF2]) -> (Bool, Integer)

module ReadingF

-- | <b>(clause2pol cs)</b> is a pair <i>(p,vs)</i>, where <i>p</i> is the
--   polynomial that corresponds to the clause <i>cs</i> (which is written
--   in DIMACS format) and <i>vs</i> is the set of its variables.
--   
--   <pre>
--   &gt;&gt;&gt; clause2pol ["1"]
--   (x1,fromList [x1])
--   
--   &gt;&gt;&gt; clause2pol ["1","-2"]
--   (x1x2+x2+1,fromList [x1,x2])
--   </pre>
clause2pol :: [String] -> (PolF2, Set (PolF2))

-- | <b>(var' lit)</b> is the pair <i>(p,v)</i>, where <i>p</i> is the
--   polynomial and <i>v</i> is the variable that corresponds (if it does)
--   to the literal <i>lit</i> (in DIMACS format).
--   
--   <pre>
--   &gt;&gt;&gt; var' "0"
--   (0,0)
--   
--   &gt;&gt;&gt; var' "1"
--   (x1,x1)
--   
--   &gt;&gt;&gt; var' "-1"
--   (x1+1,x1)
--   </pre>
var' :: String -> (PolF2, PolF2)

-- | <b>(variable2List (a,b))</b> returns a pair which first element
--   remains unchanged and the second is the list of elements of set
--   <i>b</i>. For example,
--   
--   <pre>
--   &gt;&gt;&gt; variable2List (1,S.empty)
--   (1,[])
--   
--   &gt;&gt;&gt; variable2List (x1,S.fromList[0,2])
--   (x1,[0,2])
--   </pre>
variable2List :: (t, Set a) -> (t, [a])

-- | <b>(insertPol (a,b) (acc,vs))</b> is a pair which first element is set
--   <i>acc</i> plus element <i>a</i> and the second is the union of set
--   <i>vs</i> and set <i>b</i>. For example,
--   
--   <pre>
--   &gt;&gt;&gt; insertPol (x1,S.fromList[x1]) (S.empty,S.empty)
--   (fromList [x1],fromList [x1])
--   
--   &gt;&gt;&gt; insertPol (x1*x2,S.fromList[x1,x2]) (S.fromList[x1],S.fromList[x1])
--   (fromList [x1x2,x1],fromList [x1,x2])
--   
--   &gt;&gt;&gt; insertPol (x1,S.fromList[x1]) (S.fromList[x1*x2],S.fromList[x1,x2])
--   (fromList [x1x2,x1],fromList [x1,x2])
--   </pre>
insertPol :: (PolF2, Set PolF2) -> (Set PolF2, Set PolF2) -> (Set PolF2, Set PolF2)

-- | <b>(hasV v p)</b> is 1 if <i>p</i> has the variable <i>v</i> otherwise
--   it is 0. For example,
--   
--   <pre>
--   &gt;&gt;&gt; hasV x1 x1
--   1
--   
--   &gt;&gt;&gt; hasV x2 (x1+1)
--   0
--   
--   &gt;&gt;&gt; hasV x1 (x1*x2+1)
--   1
--   </pre>
hasV :: PolF2 -> PolF2 -> Int

-- | <b>(counting (ps,vvs) cs)</b> is a list of ordered pairs in which the
--   first element is a variable from <i>vvs</i> and the second indicates
--   in how many polynomials of the set <i>ps</i> this variable occurs. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; counting (S.empty, []) []
--   []
--   
--   &gt;&gt;&gt; counting (S.fromList [x1*x2,x1,x1+1,x2], [x1,x2]) []
--   [(x2,2),(x1,3)]
--   
--   &gt;&gt;&gt; counting (S.fromList [x1], [x1,x2,x3]) []
--   [(x3,0),(x2,0),(x1,1)]
--   </pre>
counting :: (Set (PolF2), [PolF2]) -> [(PolF2, Int)] -> [(PolF2, Int)]

-- | <b>(dimacs2pols f)</b> is the pair (<i>ps</i>,<i>vs</i>) where ps is
--   the set of polynomials wich corresponds to the formula in DIMACS
--   format writed in the file <i>f</i> and <i>vs</i> is the list of
--   variables wich occurs in any polynomial.
--   
--   <pre>
--   &gt;&gt;&gt; dimacs2pols "exDIMACS/easy/example1.txt"
--   (fromList [x1x2+x1+x2,1],[x2,x1])
--   
--   &gt;&gt;&gt; dimacs2pols "exDIMACS/easy/example2.txt"
--   (fromList [x1x2+x1+x2,x1x2+x1+1,1],[x2,x1])
--   
--   &gt;&gt;&gt; dimacs2pols "exDIMACS/easy/example3.txt"
--   (fromList [x1x2+x1+x2,x1x2+x1+1,x1x2+x2+1,1],[x2,x1])
--   
--   &gt;&gt;&gt; dimacs2pols "exDIMACS/easy/example4.txt"
--   (fromList [x1x2+x1+x2,x1x2+x1+1,x1x2+x2+1,x1x2+1,1],[x2,x1])
--   </pre>
dimacs2pols :: FilePath -> IO ()
dimacs2pols' :: FilePath -> IO ()

-- | <b>(dimacs2pols f)</b> is the pair (n,m) where <i>n</i> is the size of
--   the set of polynomials wich corresponds to the formula in DIMACS
--   format writed in the file <i>f</i> and <i>m</i> is the length of the
--   list of variables wich occurs in any polynomial.
--   
--   <pre>
--   &gt;&gt;&gt; dimacs2polsSize "exDIMACS/easy/example1.txt"
--   (2,2)
--   
--   &gt;&gt;&gt; dimacs2polsSize "exDIMACS/easy/example2.txt"
--   (3,2)
--   
--   &gt;&gt;&gt; dimacs2polsSize "exDIMACS/easy/example3.txt"
--   (4,2)
--   
--   &gt;&gt;&gt; dimacs2polsSize "exDIMACS/easy/example4.txt"
--   (5,2)
--   
--   &gt;&gt;&gt; dimacs2polsSize "exDIMACS/hard/sat100.cnf"
--   (431,100)
--   
--   &gt;&gt;&gt; dimacs2polsSize "exDIMACS/hard/sat250.cnf"
--   (1066,250)
--   </pre>
dimacs2polsSize :: FilePath -> IO ()

-- | <b>(main f)</b> is verified if the set of formulas in DIMACS format in
--   the file <i>f</i> were satisfiable. Otherwise, <i>(main f)</i> would
--   return False.
--   
--   <pre>
--   &gt;&gt;&gt; main "exDIMACS/easy/example1.txt"
--   True
--   
--   &gt;&gt;&gt; main "exDIMACS/easy/example2.txt"
--   True
--   
--   &gt;&gt;&gt; main "exDIMACS/easy/example3.txt"
--   True
--   
--   &gt;&gt;&gt; main "exDIMACS/easy/example4.txt"
--   False
--   
--   &gt;&gt;&gt; main "exDIMACS/medium/exampleSat0.txt"
--   True
--   
--   &gt;&gt;&gt; main "exDIMACS/medium/exampleSat1.txt"
--   True
--   </pre>
main :: FilePath -> IO ()

-- | <b>(mainCount f)</b> returns a pair where first component is verified
--   if the set of formulas in DIMACS format in the file <i>f</i> were
--   satisfiable; and the second component counts how many times the delta
--   rule has been executed.
--   
--   <pre>
--   &gt;&gt;&gt; mainCount "exDIMACS/easy/example1.txt"
--   (True,1)
--   
--   &gt;&gt;&gt; mainCount "exDIMACS/easy/example2.txt"
--   (True,3)
--   
--   &gt;&gt;&gt; mainCount "exDIMACS/easy/example3.txt"
--   (True,7)
--   
--   &gt;&gt;&gt; mainCount "exDIMACS/easy/example4.txt"
--   (False,12)
--   
--   &gt;&gt;&gt; mainCount "exDIMACS/medium/exampleSat0.txt"
--   (True,114)
--   
--   &gt;&gt;&gt; mainCount "exDIMACS/medium/exampleSat1.txt"
--   (True,142)
--   </pre>
mainCount :: FilePath -> IO ()
mainTrace :: [Expr] -> [PolF2] -> IO ()
