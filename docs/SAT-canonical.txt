-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package SAT-canonical
@version 0.1.0.0

module Logic
type VarProp = String
data FProp
T :: FProp
F :: FProp
Atom :: VarProp -> FProp
Neg :: FProp -> FProp
Conj :: FProp -> FProp -> FProp
Disj :: FProp -> FProp -> FProp
Impl :: FProp -> FProp -> FProp
Equi :: FProp -> FProp -> FProp
p :: FProp
q :: FProp
r :: FProp
no :: FProp -> FProp
(∨) :: FProp -> FProp -> FProp
infixr 5 ∨
(∧) :: FProp -> FProp -> FProp
infixr 4 ∧
(→) :: FProp -> FProp -> FProp
infixr 3 →
(<->) :: FProp -> FProp -> FProp
infixr 2 <->

-- | For example, &gt;&gt;&gt; substitute (no p) "p" q ¬q &gt;&gt;&gt;
--   substitute (no (q ∧ no p)) "p" (q ↔ p) ¬(q ∧ ¬(q ↔ p))
substitute :: FProp -> VarProp -> FProp -> FProp
type Interpretation = [FProp]

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; signify ((p ∨ q) ∧ ((no q) ∨ r)) [r]
--   False
--   
--   &gt;&gt;&gt; signify ((p ∨ q) ∧ ((no q) ∨ r)) [p,r]
--   True
--   </pre>
signify :: FProp -> Interpretation -> Bool

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; isModelForm [r]   ((p ∨ q) ∧ ((no q) ∨ r))
--   False
--   
--   &gt;&gt;&gt; isModelForm [p,r] ((p ∨ q) ∧ ((no q) ∨ r))
--   True
--   </pre>
isModelForm :: Interpretation -> FProp -> Bool

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; propSymbolsForm (p ∧ q → p)
--   [p,q]
--   </pre>
propSymbolsForm :: FProp -> [FProp]

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; interpretationsForm (p ∧ q → p)
--   [[],[p],[q],[p,q]]
--   </pre>
interpretationsForm :: FProp -> [Interpretation]

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; modelsForm ((p ∨ q) ∧ ((no q) ∨ r))
--   [[p],[p,r],[q,r],[p,q,r]]
--   </pre>
modelsForm :: FProp -> [Interpretation]

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; isValid (p → p)
--   True
--   
--   &gt;&gt;&gt; isValid (p → q)
--   False
--   
--   &gt;&gt;&gt; isValid ((p → q) ∨ (q → p))
--   True
--   </pre>
isValid :: FProp -> Bool

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; isUnsatisfiable (p ∧ (no p))
--   True
--   
--   &gt;&gt;&gt; isUnsatisfiable ((p → q) ∧ (q → r))
--   False
--   </pre>
isUnsatisfiable :: FProp -> Bool

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; isSatisfiable (p ∧ (no p))
--   False
--   
--   &gt;&gt;&gt; isSatisfiable ((p → q) ∧ (q → r))
--   True
--   </pre>
isSatisfiable :: FProp -> Bool
type KB = Set FProp

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; propSymbolsKB (S.fromList [p ∧ q → r, p → r])
--   [p,r,q]
--   </pre>
propSymbolsKB :: KB -> [FProp]

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; interpretationsKB (S.fromList [p → q, q → r])
--   [[],[p],[q],[p,q],[r],[p,r],[q,r],[p,q,r]]
--   </pre>
interpretationsKB :: KB -> [Interpretation]

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; isModelKB [r] (S.fromList [q,no p ,r])
--   False
--   
--   &gt;&gt;&gt; isModelKB [q,r] (S.fromList [q,no p ,r])
--   True
--   </pre>
isModelKB :: Interpretation -> KB -> Bool

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; modelsKB $ S.fromList [(p ∨ q) ∧ ((no q) ∨ r), q → r]
--   [[p],[p,r],[q,r],[p,q,r]]
--   
--   &gt;&gt;&gt; modelsKB $ S.fromList [(p ∨ q) ∧ ((no q) ∨ r), r → q]
--   [[p],[q,r],[p,q,r]]
--   </pre>
modelsKB :: KB -> [Interpretation]

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; isConsistent $ S.fromList [(p ∨ q) ∧ ((no q) ∨ r), p → r]
--   True
--   
--   &gt;&gt;&gt; isConsistent $ S.fromList [(p ∨ q) ∧ ((no q) ∨ r), p → r, no r]
--   False
--   </pre>
isConsistent :: KB -> Bool

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; isInconsistent $ S.fromList [(p ∨ q) ∧ ((no q) ∨ r), p → r]
--   False
--   
--   &gt;&gt;&gt; isInconsistent $ S.fromList [(p ∨ q) ∧ ((no q) ∨ r), p → r, no r]
--   True
--   </pre>
isInconsistent :: KB -> Bool

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; isConsequence (S.fromList [p → q, q → r]) (p → r)
--   True
--   
--   &gt;&gt;&gt; isConsequence (S.fromList [p]) (p ∧ q)
--   False
--   </pre>
isConsequence :: KB -> FProp -> Bool

-- | <pre>
--   &gt;&gt;&gt; quickCheck prop_isValid
--   +++ OK, passed 100 tests.
--   </pre>
prop_isValid :: FProp -> Bool

-- | <pre>
--   &gt;&gt;&gt; quickCheck prop_isConsequence
--   +++ OK, passed 100 tests.
--   </pre>
prop_isConsequence :: KB -> FProp -> Bool

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; isConsequenceKB (S.fromList [p → q, q → r]) (S.fromList [p → q, p → r])
--   True
--   
--   &gt;&gt;&gt; isConsequenceKB (S.fromList [p]) (S.fromList [p ∧ q])
--   False
--   </pre>
isConsequenceKB :: KB -> KB -> Bool

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; equivalent (p → q) (no p ∨ q)
--   True
--   
--   &gt;&gt;&gt; equivalent (p) (no (no p))
--   True
--   </pre>
equivalent :: FProp -> FProp -> Bool

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; equivalentKB (S.fromList [p → q,r ∨ q]) (S.fromList [no p ∨ q, q ∨ r])
--   True
--   
--   &gt;&gt;&gt; equivalentKB (S.fromList [p ∧ q]) (S.fromList [q,p])
--   True
--   </pre>
equivalentKB :: KB -> KB -> Bool

-- | <pre>
--   &gt;&gt;&gt; quickCheck prop_equivalent
--   +++ OK, passed 100 tests.
--   </pre>
prop_equivalent :: FProp -> FProp -> Bool
instance GHC.Classes.Ord Logic.FProp
instance GHC.Classes.Eq Logic.FProp
instance GHC.Show.Show Logic.FProp
instance Test.QuickCheck.Arbitrary.Arbitrary Logic.FProp

module Heuristics

-- | The Heuristic data type indicates the order in which variables are
--   forgotten.
type Heuristics = Set FProp -> [VarProp] -> [VarProp]

-- | For example,
--   
--   <pre>
--   &gt;&gt;&gt; vars (p ∧ q → p)
--   ["p","q"]
--   </pre>
vars :: FProp -> [VarProp]
varsKB :: KB -> [VarProp]

-- | (<b> frequency ps vs </b>) is the list of variables vs sorted by
--   frequency of occurrence in ps. For example:
--   
--   <pre>
--   &gt;&gt;&gt; [x1,x2] = map var ["x1","x2"] :: [PolF2]
--   
--   &gt;&gt;&gt; frequency (S.fromList [x1,x2,x1+1]) [x1,x2]
--   [x2,x1]
--   </pre>
frequency :: Heuristics

-- | (<b> revFreq ps vs </b>) is the list of variables vs ordered in
--   reverse order of frequency in ps. For example:
--   
--   <pre>
--   &gt;&gt;&gt; [x1,x2] = map var ["x1","x2"] :: [PolF2]
--   
--   &gt;&gt;&gt; revFreq (S.fromList [x1,x2,x1+1]) [x1,x2]
--   [x1,x2]
--   </pre>
revFreq :: Heuristics

module LogicParser
parseFProp :: String -> Either ParseError FProp

module Simplification

-- | (withTF f) is verified if the formula <i>f</i> contains any occurrence
--   of the constants T or F:
withTF :: FProp -> Bool
simplification :: FProp -> FProp
simplification' :: FProp -> FProp

-- | <pre>
--   &gt;&gt;&gt; quickCheck prop_simp
--   +++ OK, passed 100 tests.
--   </pre>
prop_simp :: FProp -> Bool

module Preprocessing
lit :: String -> FProp
clause :: [[Char]] -> FProp

-- | <b>(dimacs f)</b> is the pair (<i>ps</i>,<i>vs</i>) where ps is the
--   set of formulas wich corresponds to the formula in DIMACS format
--   writed in the file <i>f</i> and <i>vs</i> is the list of variables
--   wich occurs in any propositional formula.
dimacs :: FilePath -> IO (Set FProp, [VarProp])

-- | <b>(formulas f)</b> is the pair (<i>ps</i>,<i>vs</i>) where ps is the
--   set of formulas wich corresponds to the formula in Prover9 format
--   writed in the file <i>f</i> and <i>vs</i> is the list of variables
--   wich occurs in any propositional formula.
formulas :: FilePath -> IO (Set FProp, [VarProp])

module Canonical
canonical :: VarProp -> FProp -> FProp -> FProp
canonical' :: VarProp -> FProp -> FProp -> FProp

module Saturation
canonicalAux :: VarProp -> FProp -> Set FProp -> Set FProp -> Set FProp
canonicalKB :: VarProp -> Set FProp -> Set FProp -> Set FProp
forgetVarKB :: VarProp -> Set FProp -> Set FProp
saturateKB :: Set FProp -> [VarProp] -> Heuristics -> Bool

module MainFunctions
forgetVarListKB :: Set FProp -> [VarProp] -> [Set FProp]
forgetVarListKB' :: Set FProp -> [VarProp] -> Heuristics -> [Set FProp]
saturateKBTrace :: Set FProp -> [VarProp] -> Heuristics -> [(Set FProp, Bool)]
saturateKBSizeTrace :: Set FProp -> [VarProp] -> Heuristics -> [((VarProp, Int), Bool)]
satFORMULAS :: FilePath -> (Set FProp -> [VarProp] -> [VarProp]) -> IO Bool
satCNF :: [Char] -> (Set FProp -> [VarProp] -> [VarProp]) -> IO Bool
